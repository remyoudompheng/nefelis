// Various utility functions for big integers (usually modulo l)
// Defines:
// BLEN: size (in number of uint words) of l, with extra bits to contains
// carries ALEN: size large enough to hold a number of size O(l^2)

#ifndef BLEN
#error Integer size is missing
#endif

#if BLEN < 2
#error BLEN is too small
#endif

// Big integer arithmetic. We need:
// - addition
// - subtraction
// - (small) quotient by p
// - add product by a small integer

// Compute x += y
void add(inout uint[BLEN] x, in uint[BLEN] y) {
  uint c = 0;
  for (uint i = 0; i < BLEN; i++) {
    if (y[i] == -1 && c == 1) {
      // x[i] is unchanged
      // set c=1 for index i+1
      continue;
    }
    x[i] = uaddCarry(x[i], y[i] + c, c);
  }
}

// Compute x -= y
void sub(inout uint[BLEN] x, in uint[BLEN] y) {
  uint c = 0;
  for (uint i = 0; i < BLEN; i++) {
    if (y[i] == -1 && c == 1) {
      // x[i] is unchanged
      // set c=1 for index i+1
      continue;
    }
    x[i] = usubBorrow(x[i], y[i] + c, c);
  }
}

void neg(inout uint[BLEN] x) {
  // -x = NOT(x) + 1
  uint c = 1;
  for (uint i = 0; i < BLEN; i++) {
    x[i] = uaddCarry(~x[i], c, c);
  }
}

// Normalizes x (vector with 64-bit limbs in base 2^32) into
// a long signed integer with 32-bit positive limbs.
void norm(out uint[BLEN] res, int64_t[BLEN] x) {
  // Assume that each abs(x[i]) is less than 2^63
  // Invariant:
  // sum(in[j] << 32j for j <= i) == sum(out[j] << 32j) + c << 32i
  int c = 0;
  for (uint i = 0; i < BLEN; i++) {
    int64_t xi = x[i] + c;
    res[i] = uint(xi);
    // signed shift makes it correct
    c = int(xi >> 32);
  }
}

// Compute y = x * s
void mul_small(out uint[BLEN] y, in uint[BLEN] x, int16_t s) {
  if (s < 0) {
    s = -s;
    neg(x);
  }
  uint c = 0;
  for (uint i = 0; i < BLEN; i++) {
    uint64_t xs = uint64_t(x[i]) * uint64_t(s) + uint64_t(c);
    y[i] = uint(xs);
    c = uint(xs >> 32);
  }
}

int16_t divp(uint[BLEN] x) {
  int64_t xhi = int64_t(pack64(u32vec2(x[BLEN - 2], x[BLEN - 1])));
  int64_t phi = int64_t(pack64(u32vec2(p[BLEN - 2], p[BLEN - 1])));
  float q = float(xhi) / float(phi);
  return int16_t(floor(q));
}

void modp(inout uint[BLEN] x) {
  int16_t q = divp(x);
  // Fused x -= q * p
  int c = 0;
  for (uint i = 0; i < BLEN; i++) {
    int64_t xi = int64_t(c) + x[i] - int64_t(q) * int64_t(p[i]);
    x[i] = uint(xi);
    c = int(xi >> 32);
  }
  // x may become negative
  if (int(x[BLEN - 1]) < 0) {
    add(x, p);
  }
}
