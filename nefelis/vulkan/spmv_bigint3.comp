// Variant of spmv.comp for computations modulo a large integer.
// To avoid redundant carries and excessive register use, the dense
// block uses a single 64-bit accumulator and online carry propagation.
//
// BLEN is such that 2^(32 BLEN - 1) is larger than N p
// where N is the norm of the matrix.
//
// Usually BLEN is between 8 and 32 (256-1024 bit moduli).
//
// Assumption: p[BLEN-2] > 2^16 (it should be larger than 2^32 / N)

#version 450

#ifndef N
#error Matrix dimension undefined
#endif

#ifndef DENSE_N
#error Dense width undefined
#endif

#ifndef BLEN
#error Integer size is missing
#endif

#if BLEN < 2
#error BLEN is too small
#endif

#extension GL_EXT_shader_explicit_arithmetic_types : require

// Each thread handles a row.
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) readonly buffer Dense { int8_t dense[]; };
layout(binding = 1) readonly buffer SparsePlus { uint16_t plus[]; };
layout(binding = 2) readonly buffer SparseMinus { uint16_t minus[]; };
layout(binding = 3) readonly buffer IdxPlus { uint idxPlus[]; };
layout(binding = 4) readonly buffer IdxMinus { uint idxMinus[]; };
// Vector of size 2N:
// even iterations do V[N:2N] = M * V[0:N]
// odd iterations do V[0:N] = M * V[N:2N]
layout(binding = 5) buffer V { uint[BLEN] v[]; };
// Vector of identical values (1 per workgroup) indicating iteration count
layout(binding = 6) buffer Iter { uint iter[]; };
layout(binding = 7) readonly buffer P { uint[BLEN] p; };
#ifdef POLYEVAL
// Polynomial sum(ak X^k)
layout(binding = 8) readonly buffer Poly { uint[BLEN] ak[]; };
// Output sum(ak M^k V) where coefficients are not reduced modulo p.
// The upper bound for values is deg(Poly)·p²
layout(binding = 9) coherent buffer Wout { uint[ALEN] wout[]; };
#else
// Output buffer for Wiedemann algorithm sequence: wout[iter] = sum(v[idx] where
// wsel[idx]=1)
layout(binding = 8) coherent buffer Wout { uint[BLOCKM][BLEN] wout[]; };
#endif

#include <bigint.comp>

shared int8_t denserow[DENSE_N][gl_WorkGroupSize.x];

void main() {
  uint idx = iter[gl_WorkGroupID.x];
  uint off0 = ((idx & 1) == 0) ? 0 : N;
  uint off1 = ((idx & 1) == 0) ? N : 0;
  uint row = gl_GlobalInvocationID.x;
  if (row >= N)
    return;
  uint[BLEN] acc;
  for (uint i = 0; i < BLEN; i++)
    acc[i] = 0;
  // Dense block: compute each word separately and batch carries
  uint dense_base = row * DENSE_N;
  for (uint i = 0; i < DENSE_N; i++)
    denserow[i][gl_LocalInvocationID.x] = dense[dense_base + i];
  int carry = 0;
  for (uint j = 0; j < BLEN; j++) {
     int64_t accj = int64_t(carry);
     for (uint i = 0; i < DENSE_N; i++)
         accj += int64_t(v[off0 + i][j]) * int64_t(denserow[i][gl_LocalInvocationID.x]);
     carry = int(accj >> 32);
     acc[j] = uint(accj);
  }
  // +1 coefficients
  uint plus0 = idxPlus[row];
  uint plus1 = idxPlus[row + 1];
  uint base = 0;
  for (uint i = plus0; i < plus1; i++) {
    uint c = plus[i];
    if (N >= 0xffff && c == 0xffff) {
      base += 0xffff;
      continue;
    }
    add(acc, v[off0 + base + c]);
  }
  // -1 coefficients
  uint minus0 = idxMinus[row];
  uint minus1 = idxMinus[row + 1];
  base = 0;
  for (uint i = minus0; i < minus1; i++) {
    uint c = minus[i];
    if (N >= 0xffff && c == 0xffff) {
      base += 0xffff;
      continue;
    }
    sub(acc, v[off0 + base + c]);
  }
  // Output result to next row
  modp(acc);
  v[off1 + row] = acc;
#ifdef POLYEVAL
  // wout[row] += ak[idx+1] * acc
  uint[ALEN] w = wout[row];
  for (uint i = 0; i < BLEN; i++) {
    uint aki = ak[idx + 1][i];
    // w += aki * W^i * acc
    uint carry = 0;
    for (uint j = 0; j < BLEN; j++) {
      if (i + j >= ALEN)
        break;
      uint64_t wij = uint64_t(aki) * uint64_t(acc[j]) + w[i + j] + carry;
      w[i + j] = uint(wij);
      carry = uint(wij >> 32);
    }
    // w[i+BLEN:] += carry
    for (uint j = i + BLEN; j < ALEN; j++) {
      w[j] = uaddCarry(w[j], carry, carry);
    }
  }
  wout[row] = w;
#else
  // FIXME: we cannot atomically add, the output sequence is: just v[0] .. v[m-1]
  if (gl_GlobalInvocationID.x < BLOCKM)
    wout[idx][gl_GlobalInvocationID.x] = acc;
#endif
  barrier();
  if (gl_LocalInvocationID.x == 0)
    iter[gl_WorkGroupID.x] = idx + 1;
}
