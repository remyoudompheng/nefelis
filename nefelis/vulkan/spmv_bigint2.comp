// Variant of spmv.comp for computations modulo a large integer.
// To avoid addition with carry, accumulators are 64-bit integers,
// normalized to 32-bit words after finishing each row.
//
// BLEN is such that 2^(32 BLEN - 1) is larger than N p
// where N is the norm of the matrix.
//
// Usually BLEN is between 8 and 32 (256-1024 bit moduli).
//
// Assumption: p[BLEN-2] > 2^16 (it should be larger than 2^32 / N)

#version 450

#ifndef N
#error Matrix dimension undefined
#endif

#ifndef DENSE_N
#error Dense width undefined
#endif

#ifndef BLEN
#error Integer size is missing
#endif

#if BLEN < 2
#error BLEN is too small
#endif

#extension GL_EXT_shader_explicit_arithmetic_types : require

// Each thread handles a row.
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) readonly buffer Dense { int8_t dense[]; };
// Array of Schirokauer maps: they are stored in Montgomery convention
// dbig[i] = SM[i] * W^BLEN % p where W = 2^32
layout(binding = 1) readonly buffer DenseBig { uint[BLEN] dbig[]; };
layout(binding = 2) readonly buffer SparsePlus { uint16_t plus[]; };
layout(binding = 3) readonly buffer SparseMinus { uint16_t minus[]; };
layout(binding = 4) readonly buffer IdxPlus { uint idxPlus[]; };
layout(binding = 5) readonly buffer IdxMinus { uint idxMinus[]; };
layout(binding = 6) readonly buffer P {
  uint[BLEN] p;
  uint[BLEN] pinv;
};
// Vector of size 2N:
// even iterations do V[N:2N] = M * V[0:N]
// odd iterations do V[0:N] = M * V[N:2N]
layout(binding = 7) buffer V { uint[BLEN] v[]; };
// Vector of identical values (1 per workgroup) indicating iteration count
layout(binding = 8) buffer Iter { uint iter[]; };
#ifdef POLYEVAL
// Polynomial sum(ak X^k)
layout(binding = 9) readonly buffer Poly { uint[BLEN] ak[]; };
// Output sum(ak M^k V) where coefficients are not reduced modulo p.
// The upper bound for values is deg(Poly)·p²
layout(binding = 10) coherent buffer Wout { uint[ALEN] wout[]; };
#else
// Output buffer for Wiedemann algorithm sequence: wout[iter] = sum(v[idx] where
// wsel[idx]=1)
layout(binding = 9) coherent buffer Wout { uint[BLOCKM][BLEN] wout[]; };
#endif

#include <bigint.comp>

void main() {
  uint idx = iter[gl_WorkGroupID.x];
  uint off0 = ((idx & 1) == 0) ? 0 : N;
  uint off1 = ((idx & 1) == 0) ? N : 0;
  uint row = gl_GlobalInvocationID.x;
  if (row >= N)
    return;
  // Signed accumulators without carry.
  // They will never excess norm(matrix) x 2^32
  int64_t[BLEN] acc;
  for (uint i = 0; i < BLEN; i++)
    acc[i] = 0;
  // Dense block
  uint dense_base = row * DENSE_N;
  for (uint i = 0; i < DENSE_N; i++) {
    for (uint j = 0; j < BLEN; j++)
      acc[j] += int64_t(v[off0 + i][j]) * int64_t(dense[dense_base + i]);
  }
  // +1 coefficients
  uint plus0 = idxPlus[row];
  uint plus1 = idxPlus[row + 1];
  uint base = 0;
  for (uint i = plus0; i < plus1; i++) {
    uint c = plus[i];
    if (N >= 0xffff && c == 0xffff) {
      base += 0xffff;
      continue;
    }
    for (uint j = 0; j < BLEN; j++)
      acc[j] += v[off0 + base + c][j];
  }
  // -1 coefficients
  uint minus0 = idxMinus[row];
  uint minus1 = idxMinus[row + 1];
  base = 0;
  for (uint i = minus0; i < minus1; i++) {
    uint c = minus[i];
    if (N >= 0xffff && c == 0xffff) {
      base += 0xffff;
      continue;
    }
    for (uint j = 0; j < BLEN; j++)
      acc[j] -= v[off0 + base + c][j];
  }
  uint[BLEN] tmp;
  norm(tmp, acc);
  // Output result to next row
#if defined(SM) || defined(POLYEVAL)
  uint[ALEN] w;
#endif
#ifdef SM
  // By convention, the index of SM coordinates are DENSE, DENSE+1...
  modp(tmp);
  for (uint i = 0; i < ALEN; i++)
    w[i] = 0;
  // In Montgomery convention, tmp must be shifted by BLEN words.
  for (uint i = 0; i < BLEN; i++)
    w[BLEN + i] = tmp[i];
  // Compute w = tmp + mi * v[DENSE_N]
  for (uint i = 0; i < BLEN; i++) {
    uint mi = dbig[row][i];
    uint carry = 0;
    for (uint j = 0; j < BLEN; j++) {
      if (i + j >= ALEN)
        break;
      uint64_t wij =
          uint64_t(mi) * uint64_t(v[off0 + DENSE_N][j]) + w[i + j] + carry;
      w[i + j] = uint(wij);
      carry = uint(wij >> 32);
    }
    // w[i+BLEN:] += carry
    for (uint j = i + BLEN; j < ALEN; j++) {
      w[j] = uaddCarry(w[j], carry, carry);
    }
  }
  // Montgomery reduction:
  // tmp = mul_low(w, pinv)
  for (uint i = 0; i < BLEN; i++)
    tmp[i] = 0;
  for (uint i = 0; i < BLEN; i++) {
    uint carry = 0;
    for (uint j = 0; j < BLEN; j++) {
      if (i + j >= BLEN)
        break;
      uint64_t wij = uint64_t(w[i]) * uint64_t(pinv[j]) + tmp[i + j] + carry;
      tmp[i + j] = uint(wij);
      carry = uint(wij >> 32);
    }
  }
  // w += tmp * p
  for (uint i = 0; i < BLEN; i++) {
    uint carry = 0;
    for (uint j = 0; j < BLEN; j++) {
      if (i + j >= ALEN)
        break;
      uint64_t wij = uint64_t(tmp[i]) * uint64_t(p[j]) + w[i + j] + carry;
      w[i + j] = uint(wij);
      carry = uint(wij >> 32);
    }
    // w[i+BLEN:] += carry
    for (uint j = i + BLEN; j < ALEN; j++) {
      w[j] = uaddCarry(w[j], carry, carry);
    }
  }
  // Shift left
  for (uint i = 0; i < BLEN; i++)
    tmp[i] = w[BLEN + i];
#endif
  modp(tmp);
  v[off1 + row] = tmp;
#ifdef POLYEVAL
  // wout[row] += ak[idx+1] * acc
  w = wout[row];
  for (uint i = 0; i < BLEN; i++) {
    uint aki = ak[idx + 1][i];
    // w += aki * W^i * acc
    uint carry = 0;
    for (uint j = 0; j < BLEN; j++) {
      if (i + j >= ALEN)
        break;
      uint64_t wij = uint64_t(aki) * uint64_t(tmp[j]) + w[i + j] + carry;
      w[i + j] = uint(wij);
      carry = uint(wij >> 32);
    }
    // w[i+BLEN:] += carry
    for (uint j = i + BLEN; j < ALEN; j++) {
      w[j] = uaddCarry(w[j], carry, carry);
    }
  }
  wout[row] = w;
#else
  // FIXME: we cannot atomically add, the output sequence is: just v[0] .. v[m-1]
  if (gl_GlobalInvocationID.x < BLOCKM)
    wout[idx][gl_GlobalInvocationID.x] = tmp;
#endif
  barrier();
  if (gl_LocalInvocationID.x == 0)
    iter[gl_WorkGroupID.x] = idx + 1;
}
